const Chat = require('../models/Chat');
const User = require('../models/User');
const Product = require('../models/Product');

// Auto response system with enhanced logic
const getAutoResponse = async (userMessage, userId) => {
  const message = userMessage.toLowerCase();
  let responseType = 'default';
  let response = '';
  
  try {
    // Greeting responses
    if (message.includes('ch√†o') || message.includes('hello') || message.includes('hi')) {
      responseType = 'greeting';
      response = 'Ch√†o b·∫°n! R·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n h√¥m nay. B·∫°n c·∫ßn t√¨m hi·ªÉu v·ªÅ s·∫£n ph·∫©m n√†o?';
    }
    
    // Product related queries with database integration
    else if (message.includes('√°o') || message.includes('shirt') || message.includes('t-shirt')) {
      responseType = 'product_info';
      try {
        const products = await Product.find({ 
          name: { $regex: /√°o|shirt|t-shirt/i } 
        }).limit(3);
        
        if (products.length > 0) {
          const productList = products.map(p => `‚Ä¢ ${p.name} - ${p.price.toLocaleString('vi-VN')} VNƒê`).join('\n');
          response = `Ch√∫ng t√¥i c√≥ r·∫•t nhi·ªÅu lo·∫°i √°o nam. ƒê√¢y l√† m·ªôt s·ªë s·∫£n ph·∫©m hot:\n\n${productList}\n\nB·∫°n mu·ªën xem th√™m chi ti·∫øt s·∫£n ph·∫©m n√†o?`;
        } else {
          response = 'Ch√∫ng t√¥i c√≥ r·∫•t nhi·ªÅu lo·∫°i √°o nam: √°o s∆° mi, √°o thun, √°o polo, √°o hoodie. B·∫°n mu·ªën xem lo·∫°i n√†o? T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t√¨m theo size, m√†u s·∫Øc ho·∫∑c gi√° c·∫£.';
        }
      } catch (err) {
        response = 'Ch√∫ng t√¥i c√≥ r·∫•t nhi·ªÅu lo·∫°i √°o nam: √°o s∆° mi, √°o thun, √°o polo, √°o hoodie. B·∫°n mu·ªën xem lo·∫°i n√†o? T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t√¨m theo size, m√†u s·∫Øc ho·∫∑c gi√° c·∫£.';
      }
    }
    
    else if (message.includes('qu·∫ßn') || message.includes('pants') || message.includes('jeans')) {
      responseType = 'product_info';
      try {
        const products = await Product.find({ 
          name: { $regex: /qu·∫ßn|pants|jeans/i } 
        }).limit(3);
        
        if (products.length > 0) {
          const productList = products.map(p => `‚Ä¢ ${p.name} - ${p.price.toLocaleString('vi-VN')} VNƒê`).join('\n');
          response = `Manzone c√≥ ƒëa d·∫°ng c√°c lo·∫°i qu·∫ßn. ƒê√¢y l√† m·ªôt s·ªë s·∫£n ph·∫©m n·ªïi b·∫≠t:\n\n${productList}\n\nB·∫°n ƒëang t√¨m lo·∫°i n√†o v√† size bao nhi√™u?`;
        } else {
          response = 'Manzone c√≥ ƒëa d·∫°ng c√°c lo·∫°i qu·∫ßn: qu·∫ßn jeans, qu·∫ßn kaki, qu·∫ßn short, qu·∫ßn t√¢y. B·∫°n ƒëang t√¨m lo·∫°i n√†o v√† size bao nhi√™u?';
        }
      } catch (err) {
        response = 'Manzone c√≥ ƒëa d·∫°ng c√°c lo·∫°i qu·∫ßn: qu·∫ßn jeans, qu·∫ßn kaki, qu·∫ßn short, qu·∫ßn t√¢y. B·∫°n ƒëang t√¨m lo·∫°i n√†o v√† size bao nhi√™u?';
      }
    }
    
    // Pricing queries with real data
    else if (message.includes('gi√°') || message.includes('price') || message.includes('bao nhi√™u')) {
      responseType = 'pricing';
      try {
        const priceRanges = await Product.aggregate([
          {
            $group: {
              _id: null,
              minPrice: { $min: '$price' },
              maxPrice: { $max: '$price' },
              avgPrice: { $avg: '$price' }
            }
          }
        ]);
        
        if (priceRanges.length > 0) {
          const { minPrice, maxPrice, avgPrice } = priceRanges[0];
          response = `Gi√° s·∫£n ph·∫©m c·ªßa ch√∫ng t√¥i r·∫•t c·∫°nh tranh:\n‚Ä¢ Gi√° t·ª´: ${minPrice.toLocaleString('vi-VN')} VNƒê\n‚Ä¢ Gi√° cao nh·∫•t: ${maxPrice.toLocaleString('vi-VN')} VNƒê\n‚Ä¢ Gi√° trung b√¨nh: ${Math.round(avgPrice).toLocaleString('vi-VN')} VNƒê\n\nB·∫°n c√≥ th·ªÉ xem chi ti·∫øt gi√° t·ª´ng s·∫£n ph·∫©m trong danh m·ª•c ho·∫∑c cho t√¥i bi·∫øt s·∫£n ph·∫©m c·ª• th·ªÉ b·∫°n quan t√¢m.`;
        } else {
          response = 'Gi√° s·∫£n ph·∫©m c·ªßa ch√∫ng t√¥i r·∫•t c·∫°nh tranh:\n‚Ä¢ √Åo thun: 200.000 - 500.000 VNƒê\n‚Ä¢ √Åo s∆° mi: 350.000 - 800.000 VNƒê\n‚Ä¢ Qu·∫ßn jeans: 400.000 - 900.000 VNƒê\n‚Ä¢ Qu·∫ßn kaki: 300.000 - 700.000 VNƒê\nB·∫°n c√≥ th·ªÉ xem chi ti·∫øt gi√° t·ª´ng s·∫£n ph·∫©m trong danh m·ª•c.';
        }
      } catch (err) {
        response = 'Gi√° s·∫£n ph·∫©m c·ªßa ch√∫ng t√¥i r·∫•t c·∫°nh tranh:\n‚Ä¢ √Åo thun: 200.000 - 500.000 VNƒê\n‚Ä¢ √Åo s∆° mi: 350.000 - 800.000 VNƒê\n‚Ä¢ Qu·∫ßn jeans: 400.000 - 900.000 VNƒê\n‚Ä¢ Qu·∫ßn kaki: 300.000 - 700.000 VNƒê\nB·∫°n c√≥ th·ªÉ xem chi ti·∫øt gi√° t·ª´ng s·∫£n ph·∫©m trong danh m·ª•c.';
      }
    }
    
    else if (message.includes('size') || message.includes('k√≠ch th∆∞·ªõc') || message.includes('c·ª°')) {
      responseType = 'product_info';
      response = 'Ch√∫ng t√¥i c√≥ ƒë·∫ßy ƒë·ªß c√°c size t·ª´ S ƒë·∫øn XXL:\n‚Ä¢ S: 50-55kg (Ng·ª±c: 88-92cm)\n‚Ä¢ M: 55-65kg (Ng·ª±c: 92-96cm)\n‚Ä¢ L: 65-75kg (Ng·ª±c: 96-100cm)\n‚Ä¢ XL: 75-85kg (Ng·ª±c: 100-104cm)\n‚Ä¢ XXL: 85-95kg (Ng·ª±c: 104-108cm)\n\nB·∫°n c√≥ th·ªÉ tham kh·∫£o b·∫£ng size chi ti·∫øt trong m·ªói s·∫£n ph·∫©m ho·∫∑c li√™n h·ªá ƒë·ªÉ ƒë∆∞·ª£c t∆∞ v·∫•n size ph√π h·ª£p.';
    }
    
    else if (message.includes('giao h√†ng') || message.includes('ship') || message.includes('delivery')) {
      responseType = 'shipping';
      response = 'Ch√∫ng t√¥i h·ªó tr·ª£ giao h√†ng to√†n qu·ªëc:\n‚Ä¢ N·ªôi th√†nh HCM/HN: 1-2 ng√†y\n‚Ä¢ Ngo·∫°i th√†nh: 2-3 ng√†y\n‚Ä¢ T·ªânh th√†nh kh√°c: 3-5 ng√†y\n‚Ä¢ V√πng xa: 5-7 ng√†y\n\nPh√≠ ship: 30.000 VNƒê (Mi·ªÖn ph√≠ cho ƒë∆°n h√†ng t·ª´ 500.000 VNƒê)\n\nCh√∫ng t√¥i cam k·∫øt giao h√†ng an to√†n, ƒë√∫ng h·∫πn!';
    }
    
    else if (message.includes('thanh to√°n') || message.includes('payment') || message.includes('pay')) {
      responseType = 'support';
      response = 'Ch√∫ng t√¥i h·ªó tr·ª£ nhi·ªÅu h√¨nh th·ª©c thanh to√°n an to√†n:\n‚Ä¢ üíµ Ti·ªÅn m·∫∑t khi nh·∫≠n h√†ng (COD)\n‚Ä¢ üè¶ Chuy·ªÉn kho·∫£n ng√¢n h√†ng\n‚Ä¢ üì± V√≠ ƒëi·ªán t·ª≠ MoMo\n‚Ä¢ üí≥ Th·∫ª t√≠n d·ª•ng/ghi n·ª£ Visa, Mastercard\n‚Ä¢ üé´ V√≠ ShopeePay, ZaloPay\n\nT·∫•t c·∫£ ƒë·ªÅu ƒë∆∞·ª£c m√£ h√≥a b·∫£o m·∫≠t SSL 256-bit!';
    }
    
    else if (message.includes('ƒë·ªïi tr·∫£') || message.includes('return') || message.includes('exchange')) {
      responseType = 'support';
      response = 'Ch√≠nh s√°ch ƒë·ªïi tr·∫£ c·ªßa Manzone:\n‚úÖ ƒê·ªïi tr·∫£ trong 7 ng√†y k·ªÉ t·ª´ khi nh·∫≠n h√†ng\n‚úÖ S·∫£n ph·∫©m c√≤n nguy√™n tag, ch∆∞a qua s·ª≠ d·ª•ng\n‚úÖ Mi·ªÖn ph√≠ ƒë·ªïi size (trong 3 ng√†y ƒë·∫ßu)\n‚úÖ Ho√†n ti·ªÅn 100% n·∫øu l·ªói t·ª´ shop\n‚úÖ H·ªó tr·ª£ ƒë·ªïi tr·∫£ t·∫°i nh√†\n\nLi√™n h·ªá hotline ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ nhanh ch√≥ng!';
    }
    
    else if (message.includes('hotline') || message.includes('li√™n h·ªá') || message.includes('contact')) {
      responseType = 'support';
      response = 'Th√¥ng tin li√™n h·ªá Manzone:\nüìû Hotline: 1900-1234 (mi·ªÖn ph√≠)\nüìß Email: support@manzone.vn\nüìç ƒê·ªãa ch·ªâ: 123 Nguy·ªÖn VƒÉn C·ª´, Q.5, TP.HCM\nüïê Gi·ªù l√†m vi·ªác: 8:00 - 22:00 (T2-CN)\nüí¨ Live Chat: Ngay t·∫°i ƒë√¢y\nüì± Fanpage: fb.com/ManzoneFashion\n\nCh√∫ng t√¥i lu√¥n s·∫µn s√†ng h·ªó tr·ª£ b·∫°n 24/7!';
    }
    
    else if (message.includes('sale') || message.includes('gi·∫£m gi√°') || message.includes('khuy·∫øn m√£i')) {
      responseType = 'product_info';
      response = 'Ch∆∞∆°ng tr√¨nh khuy·∫øn m√£i HOT ƒëang di·ªÖn ra:\nüî• Gi·∫£m 20% cho kh√°ch h√†ng m·ªõi (m√£: NEW20)\nüéÅ Mua 2 t·∫∑ng 1 cho √°o thun basic\nüí• Gi·∫£m 15% cho ƒë∆°n h√†ng t·ª´ 1 tri·ªáu (m√£: SAVE15)\n‚ö° Flash sale cu·ªëi tu·∫ßn gi·∫£m ƒë·∫øn 50%\nüõçÔ∏è Freeship to√†n qu·ªëc cho ƒë∆°n t·ª´ 500K\n\nH√£y theo d√µi app ƒë·ªÉ kh√¥ng b·ªè l·ª° ∆∞u ƒë√£i!';
    }
    
    // Search for specific products
    else if (message.includes('t√¨m') || message.includes('search') || message.includes('c√≥')) {
      responseType = 'product_info';
      try {
        // Try to extract product keywords
        const keywords = message.split(' ').filter(word => 
          word.length > 2 && 
          !['t√¨m', 'c√≥', 'kh√¥ng', 'ƒë∆∞·ª£c', 'cho', 'c·ªßa', 'trong', 'v√†', 'v·ªõi'].includes(word)
        );
        
        if (keywords.length > 0) {
          const searchQuery = keywords.join('|');
          const products = await Product.find({ 
            $or: [
              { name: { $regex: searchQuery, $options: 'i' } },
              { description: { $regex: searchQuery, $options: 'i' } }
            ]
          }).limit(5);
          
          if (products.length > 0) {
            const productList = products.map(p => 
              `‚Ä¢ ${p.name} - ${p.price.toLocaleString('vi-VN')} VNƒê`
            ).join('\n');
            response = `T√¥i t√¨m th·∫•y ${products.length} s·∫£n ph·∫©m ph√π h·ª£p:\n\n${productList}\n\nB·∫°n mu·ªën xem chi ti·∫øt s·∫£n ph·∫©m n√†o?`;
          } else {
            response = 'Xin l·ªói, t√¥i kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ph√π h·ª£p v·ªõi t·ª´ kh√≥a c·ªßa b·∫°n. B·∫°n c√≥ th·ªÉ th·ª≠ t√¨m v·ªõi t·ª´ kh√≥a kh√°c ho·∫∑c duy·ªát qua danh m·ª•c s·∫£n ph·∫©m c·ªßa ch√∫ng t√¥i.';
          }
        } else {
          response = 'B·∫°n mu·ªën t√¨m s·∫£n ph·∫©m g√¨? H√£y cho t√¥i bi·∫øt c·ª• th·ªÉ h∆°n nh∆∞: √°o s∆° mi, qu·∫ßn jeans, gi√†y th·ªÉ thao... ƒë·ªÉ t√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n t·ªët h∆°n.';
        }
      } catch (err) {
        response = 'B·∫°n mu·ªën t√¨m s·∫£n ph·∫©m g√¨? H√£y cho t√¥i bi·∫øt c·ª• th·ªÉ h∆°n ƒë·ªÉ t√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n t·ªët h∆°n.';
      }
    }
    
    // Default responses
    else {
      const defaultResponses = [
        'C·∫£m ∆°n b·∫°n ƒë√£ li√™n h·ªá! T√¥i ƒëang t√¨m hi·ªÉu th√¥ng tin ƒë·ªÉ h·ªó tr·ª£ b·∫°n t·ªët nh·∫•t. B·∫°n c√≥ th·ªÉ cho t√¥i bi·∫øt chi ti·∫øt h∆°n ƒë∆∞·ª£c kh√¥ng?',
        'T√¥i hi·ªÉu b·∫°n ƒëang quan t√¢m ƒë·∫øn s·∫£n ph·∫©m c·ªßa ch√∫ng t√¥i. B·∫°n c√≥ th·ªÉ xem th√™m trong danh m·ª•c s·∫£n ph·∫©m ho·∫∑c cho t√¥i bi·∫øt b·∫°n c·∫ßn t√¨m g√¨ c·ª• th·ªÉ?',
        'ƒê·ªÉ t√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n t·ªët h∆°n, b·∫°n c√≥ th·ªÉ n√≥i r√µ h∆°n v·ªÅ nhu c·∫ßu c·ªßa m√¨nh kh√¥ng? V√≠ d·ª•: lo·∫°i s·∫£n ph·∫©m, size, m√†u s·∫Øc, gi√° c·∫£...',
        'T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t√¨m s·∫£n ph·∫©m, t∆∞ v·∫•n size, gi·∫£i ƒë√°p v·ªÅ gi√° c·∫£, ch√≠nh s√°ch ƒë·ªïi tr·∫£... B·∫°n c·∫ßn h·ªó tr·ª£ g√¨ c·ª• th·ªÉ?'
      ];
      
      response = defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
    }
    
    return { response, responseType };
    
  } catch (error) {
    console.error('Error in getAutoResponse:', error);
    return {
      response: 'Xin l·ªói, h·ªá th·ªëng ƒëang g·∫∑p s·ª± c·ªë. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá hotline 1900-1234 ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.',
      responseType: 'default'
    };
  }
};

// Get chat history
const getChatHistory = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const userId = req.user.id;
    
    const chat = await Chat.findOne({ 
      user_id: userId, 
      session_id: sessionId 
    }).populate('user_id', 'full_name email');
    
    if (!chat) {
      return res.status(404).json({
        success: false,
        message: 'Chat session not found'
      });
    }
    
    const recentMessages = chat.getRecentMessages(100);
    
    res.json({
      success: true,
      data: {
        sessionId: chat.session_id,
        messages: recentMessages,
        totalMessages: chat.total_messages,
        lastActivity: chat.last_activity,
        status: chat.status
      }
    });
    
  } catch (error) {
    console.error('Error getting chat history:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// Send message
const sendMessage = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { message } = req.body;
    const userId = req.user.id;
    
    if (!message || message.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Message content is required'
      });
    }
    
    if (message.length > 2000) {
      return res.status(400).json({
        success: false,
        message: 'Message too long (max 2000 characters)'
      });
    }
    
    // Find or create chat session
    let chat = await Chat.findOrCreateSession(userId, sessionId);
    
    // Add user message
    const userMessage = chat.addMessage(message.trim(), true);
    
    // Generate bot response
    const { response, responseType } = await getAutoResponse(message.trim(), userId);
    
    // Add bot response after a delay (simulate typing)
    setTimeout(async () => {
      try {
        const botMessage = chat.addMessage(response, false, responseType);
        await chat.save();
        
        // Emit to socket if available
        const io = req.app.get('io');
        if (io) {
          io.to(`user_${userId}`).emit('newMessage', {
            sessionId: sessionId,
            message: {
              message_id: botMessage.message_id,
              text: botMessage.text,
              is_user: false,
              timestamp: botMessage.timestamp,
              response_type: botMessage.response_type
            }
          });
        }
      } catch (error) {
        console.error('Error saving bot response:', error);
      }
    }, 1000 + Math.random() * 2000); // 1-3 seconds delay
    
    // Save user message immediately
    await chat.save();
    
    // Emit user message to socket
    const io = req.app.get('io');
    if (io) {
      io.to(`user_${userId}`).emit('newMessage', {
        sessionId: sessionId,
        message: {
          message_id: userMessage.message_id,
          text: userMessage.text,
          is_user: true,
          timestamp: userMessage.timestamp
        }
      });
    }
    
    res.json({
      success: true,
      data: {
        message: {
          message_id: userMessage.message_id,
          text: userMessage.text,
          is_user: true,
          timestamp: userMessage.timestamp
        }
      }
    });
    
  } catch (error) {
    console.error('Error sending message:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// Get user's chat sessions
const getChatSessions = async (req, res) => {
  try {
    const userId = req.user.id;
    const { page = 1, limit = 10 } = req.query;
    
    const skip = (page - 1) * limit;
    
    const sessions = await Chat.find({ user_id: userId })
      .select('session_id last_activity total_messages status messages')
      .sort({ last_activity: -1 })
      .skip(skip)
      .limit(parseInt(limit));
    
    const sessionsWithLastMessage = sessions.map(session => {
      const lastMessage = session.messages[session.messages.length - 1];
      return {
        session_id: session.session_id,
        last_activity: session.last_activity,
        total_messages: session.total_messages,
        status: session.status,
        last_message: lastMessage ? {
          text: lastMessage.text.substring(0, 100) + (lastMessage.text.length > 100 ? '...' : ''),
          is_user: lastMessage.is_user,
          timestamp: lastMessage.timestamp
        } : null
      };
    });
    
    const total = await Chat.countDocuments({ user_id: userId });
    
    res.json({
      success: true,
      data: {
        sessions: sessionsWithLastMessage,
        pagination: {
          current_page: parseInt(page),
          total_pages: Math.ceil(total / limit),
          total_sessions: total,
          has_next: page * limit < total,
          has_prev: page > 1
        }
      }
    });
    
  } catch (error) {
    console.error('Error getting chat sessions:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// Create new chat session
const createChatSession = async (req, res) => {
  try {
    const userId = req.user.id;
    const sessionId = `session_${userId}_${Date.now()}`;
    
    const chat = await Chat.findOrCreateSession(userId, sessionId);
    
    res.json({
      success: true,
      data: {
        sessionId: chat.session_id,
        messages: chat.getRecentMessages(50),
        created_at: chat.created_at
      }
    });
    
  } catch (error) {
    console.error('Error creating chat session:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// Close chat session
const closeChatSession = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const userId = req.user.id;
    
    const chat = await Chat.findOne({ 
      user_id: userId, 
      session_id: sessionId 
    });
    
    if (!chat) {
      return res.status(404).json({
        success: false,
        message: 'Chat session not found'
      });
    }
    
    chat.status = 'closed';
    await chat.save();
    
    res.json({
      success: true,
      message: 'Chat session closed successfully'
    });
    
  } catch (error) {
    console.error('Error closing chat session:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

module.exports = {
  getChatHistory,
  sendMessage,
  getChatSessions,
  createChatSession,
  closeChatSession
};
